\chapter{Porting the dependencies}\label{tangservice}

Programs don’t run in a vacuum but they interface with the outside world.
The view of this outside world differs from environment to environment.
Things like hostnames, system resources, and local conventions could be different.

When we start porting a code to a specific target platform, in our case OpenWrt, it is likely that we will face the first problem: satisfying missing dependencies.
This problem is easy to solve in principle, but can easily mess things up to a level we wouldn’t imagine.

If the code depends on some library that is NOT in the root filesystem, there’s no way out but to find them somewhere, somehow.
Dependencies can be satisfied in two ways: with static libraries or with shared libraries.
If we are lucky, we could find a binary package providing what we need (i.e. the library files and the header files), but most often we will have to cross-compile the source code on our own.
Either ways, we end up with one or more binary files and a bunch of header files.
Where to put them? Well, that depends.
There are a few different situations that can happen, but basically everything reduces to having dependencies in buildroot's root filesystem or in a different folder.

Having dependencies in a different folder could be an interesting solution to keep the libraries that we cross-compiled on our own separated from the other libraries (for example, the system libraries).
We can do that if we want but if we do, we must remember to provide to compiler and linker programs with the paths where header files and binary files can be found.
With static libraries, this information are only needed at compile and linking time, but if we are using shared libraries, this won’t suffice.
We must also specify where these libraries can be found at run time.

If we are satisfying the dependencies with shared libraries (.so files) having dependencies in root filesystem is probably the most common solution (and maybe, the best solution).
Remember that when everything will be up and running, these libraries must be installed somewhere in the file system of the target platform.
So there is a natural answer to the question above: install them in the target's root filesystem, for example in /usr/lib (the binary shared files) and /usr/include (the header files) or in any other path that allow the loader to find those libraries when the program executes.
Do not forget to install them in the file system of the actual target machine, in the same places, in order to make everything work as expected.
Please note that static libraries (‘.a’ files) does not need to be installed in the target file system since their code is embedded in the executable file when we cross-compile a program.
In case of OpenWrt we will use this approach.



\section{Find the depencies}

To port Tang to OpenWrt system we have have all its dependencies available and installed in buildroot.
First thing we should do is some digging and find out if dependencies for our software, we are about to port, are available for target's platform.
All packages available for OpenWrt can be found in its github repositories.
Let us remember Tang's dependencies first:

\begin{itemize}
\item http-parser
\item systemd's socket activation
\item José
    \begin{itemize}
    \item jansson
    \item openssl
    \item zlib
    \end{itemize}
\end{itemize}

After some digging we will find out that the OpenWrt system has already packages openssl, zlib, http-parser, and jansson.
Packages openssl and zlib are in versions already sufficient for Tang to get things work.

Package http-parser was little bit tricky.
At first try there is a chance that we will not find this package in OpenWrt's repository.
The reason might be that we will try to find a exactly "http-parser" string in OpenWrt's GitHub repository openwrt/openwrt only.
First of all, we must not forget that feeds of many packages are living in repository packages nested under openwrt organization.
Secondly after searching repository openwrt/packages for http-parser we will find out that it is named as libhttp-parser and in version 2.2.3.
This, let us say naming convention, is really common in Linux and could be predictable as the http-parser is in fact only a library.
One way or another compared to fedora packages it needs to be updated to latest version.

Jansson package was only available in version 2.7 which is too outdated for Tang's dependency José because it require at least jansson version 2.10.
We shall not forget that there is a need for updating jansson package for OpenWrt platform as well so we will do updates first.

Packages José, Tang and systemd are not listed in OpenWrt's packages.
Porting of the systemd would be huge effort but tang's requirements are minimal and we should be able to work with xinetd's socket activation.
Finally, as José and Tang are not listed in packages they will require to add them into package feeds to port Tang itself.

We will use fork of openwrt/packages repository placed outside of the buildroot package:
\begin{lstlisting}[columns=fixed,basicstyle=\ttfamily\footnotesize,tabsize=4,backgroundcolor=\color{yellow!10}]
$ git clone git@github.com:Tiboris/packages-OpenWrt.git
\end{lstlisting}



\section{Update outdated packages}

Finding that some of dependencies are already available on our desired target platform will definitelly make us satisfied.
We would agree that starting with something already built for OpenWrt is the best thing to do when we are approaching unknown platform.
In following subsections we will use all things we know from section \ref{working-with-buildroot} Working with buildroot.
Let us start with missing update of José's dependency, package jansson.



\subsection{Update jansson}\label{jansson}
Jansson is a C library for encoding, decoding and manipulating JSON data.
The latest release of the jansson is v2.11 released on 11th of February 2018\cite{jansson}.

However at the begining of the Tang porting efort started the latest release was v2.10.
To update mentioned OpenWrt available jansson package version v2.7 to 2.10 change to package's fork directory and create a new branch for changes:

\begin{lstlisting}[columns=fixed,basicstyle=\ttfamily\footnotesize,tabsize=4,backgroundcolor=\color{yellow!10}]
$ cd ~/packages-OpenWrt
$ git checkout -b jansson-update
\end{lstlisting}
In order to tell the OpenWrt buildroot how to build a program we need to create a special Makefile in the appropriate directory.
The appendix \ref{hello_mkfile} Example OpenWrt package's Makefile ilustrate its content.
We shall now find the jansson package Makefile in the repository using for example:
\begin{lstlisting}[columns=fixed,basicstyle=\ttfamily\footnotesize,tabsize=4,backgroundcolor=\color{yellow!10}]
$ git grep jansson | grep PKG_NAME
libs/jansson/Makefile:PKG_NAME:=jansson
\end{lstlisting}
The {\it PKG\_NAME} variable is one that identifies package for OpenWrt buildroot\cite{creating_pkgs}.
List of all available variables can be found on the OpenWrt wiki page\footnote{https://wiki.openwrt.org/doc/devel/packages}.
We can assume that the jansson library related files are located in libs/jansson directory of the packages repository.
Now we can now update Makefile.

We will open it with our preferred editor and find variable {\it PKG\_VERSION}.
Edit the old version number (in our case 2.7) to new version number (2.10).
This edit will result into changing the {\it PKG\_SOURCE} variable in Makefile.
Variables {\it PKG\_SOURCE} and {\it PKG\_SOURCE\_URL} are used to identify location of the archive with sources for specified version from where the sources would be downloaded.
After the downaload the OpenWrt buildroot checks the file integrity.
The {\it PKG\_HASH} and {\it PKG\_MD5SUM} variables serve this purpose.
As the new version of archive with sources will be downloaded we need to change {\it PKG\_HASH}/{\it PKG\_MD5SUM} variable as well.
For some reason upstream developers required the use of {\it PKG\_HASH} variable and the bz2 archive for the jansson package.
In general it would be sufficient to change only version and the appropriate {\it PKG\_HASH}/{\it PKG\_MD5SUM} variable.
We changed the filename extension for {\it PKG\_SOURCE} variable from ".tar.gz" to ".tar.bz2".
Now download the archive containing sources and get the archive hash using sha256sum:
\begin{lstlisting}[columns=fixed,basicstyle=\ttfamily\footnotesize,tabsize=4,backgroundcolor=\color{yellow!10}]
$ wget http://www.digip.org/jansson/releases/jansson-2.10.tar.bz2 -P /tmp
$ sha256sum /tmp/jansson-2.10.tar.bz2 | cut -d " " -f1
241125a55f739cd713808c4e0089986b8c3da746da8b384952912ad659fa2f5a
\end{lstlisting}
Last but not least commit the changes and push the changes into our fork.
\begin{lstlisting}[columns=fixed,basicstyle=\ttfamily\footnotesize,tabsize=4,backgroundcolor=\color{yellow!10}]
$ git commit -a
$ git push --set-upstream origin jansson-update
\end{lstlisting}

Before submitting the pull request we should try to build updated package first.
Let us remember that we have special branch set up for buildroot feeds.
We will use this branch to merge our newly created branch into it using:
\begin{lstlisting}[columns=fixed,basicstyle=\ttfamily\footnotesize,tabsize=4,backgroundcolor=\color{yellow!10}]
$ git checkout new_packages
$ git merge jansson-update
\end{lstlisting}
After successfull merge we have updated jansson package available in our custom feeds.
Trigger update with feeds script and make jansson available in menuconfig with:
\begin{lstlisting}[columns=fixed,basicstyle=\ttfamily\footnotesize,tabsize=4,backgroundcolor=\color{yellow!10}]
$ ./scripts/feeds update packages
$ ./scripts/feeds install jansson
\end{lstlisting}
To finally build package we shall run the command:
\begin{lstlisting}[columns=fixed,basicstyle=\ttfamily\footnotesize,tabsize=4,backgroundcolor=\color{yellow!10}]
$ make package/jansson/{clean,compile} V=s
\end{lstlisting}

After successfull build the most important part would be to contribute changes to the upstream.
Update of jansson is already done through merged pull-request\footnote{https://github.com/openwrt/packages/pull/4289}.
With a knowledge of buildroot and the contribution guidelines effort spent on such updates may be quite minimal.



\subsection{Update http-parser}\label{http-parser}
Tang uses this parser library for both parsing HTTP requests and HTTP responses.
Sources can be found on its GitHub page\footnote{https://github.com/nodejs/http-parser}.

The lastest release available at the time was version v2.7.1 untill 9th February's 2018 release of v2.8.0 which update will be demonstrated below.
Fedora is still using version v2.7.1 with Tang server so compared to last available version on OpenWrt which was v2.3.0 an update is needed.
Hoping for the best we first thy to update the libhttp-parser to version v2.7.1 to match Fedora version similar way as with jansson.
Only updating version of the package may suffice but the case of libhttp-parser as dependency was special as you will notice in subsection \ref{http_parser_problems} Hurdles with http-parser.
To upgrade this package we will do same as with jansson package.
First make sure that we are still in packages repository and create branch for the change:
\begin{lstlisting}[columns=fixed,basicstyle=\ttfamily\footnotesize,tabsize=4,backgroundcolor=\color{yellow!10}]
$ git checkout master
$ git checkout -b libhttp-parser-update
\end{lstlisting}
Let us locate the http-parser Makefile:
\begin{lstlisting}[columns=fixed,basicstyle=\ttfamily\footnotesize,tabsize=4,backgroundcolor=\color{yellow!10}]
$ git grep http-parser | grep PKG_NAME
libs/libhttp-parser/Makefile:PKG_NAME:=libhttp-parser
\end{lstlisting}
Find out the source url to download the archive containing and get the archive hash using sha256sum:
\begin{lstlisting}[columns=fixed,basicstyle=\ttfamily\footnotesize,tabsize=4,backgroundcolor=\color{yellow!10}]
$ wget https://github.com/nodejs/http-parser/archive/v2.8.0.tar.xz -P /tmp
$ sha256sum /tmp/v2.8.0.tar.gz | cut -d " " -f1
83acea397da4cdb9192c27abbd53a9eb8e5a9e1bcea2873b499f7ccc0d68f518
\end{lstlisting}
Please note the file extension in old makefile and donwload same filetype for upgrade.

Before commiting the changes we also realized that owner of the repository changed from "joyent" to "nodejs" so we addressed these changes as well by editing propper sections.
We shall now edit correspondent variables, commit the changes and push them into our fork.
\begin{lstlisting}[columns=fixed,basicstyle=\ttfamily\footnotesize,tabsize=4,backgroundcolor=\color{yellow!10}]
$ git commit -a
$ git push --set-upstream origin libhttp-parser-update
\end{lstlisting}
Again merge the libhttp-parser-update branch with feeds branch:
\begin{lstlisting}[columns=fixed,basicstyle=\ttfamily\footnotesize,tabsize=4,backgroundcolor=\color{yellow!10}]
$ git checkout new_packages
$ git merge libhttp-parser-update
\end{lstlisting}
After successfull merge trigger update with feeds script and make new version of libhttp-parser package available in menuconfig:
\begin{lstlisting}[columns=fixed,basicstyle=\ttfamily\footnotesize,tabsize=4,backgroundcolor=\color{yellow!10}]
$ ./scripts/feeds update packages
$ ./scripts/feeds install libhttp-parser
\end{lstlisting}
Finally build an updated libhttp-parser running:
\begin{lstlisting}[columns=fixed,basicstyle=\ttfamily\footnotesize,tabsize=4,backgroundcolor=\color{yellow!10}]
$ make package/libhttp-parser/{clean,compile} V=s
\end{lstlisting}
The update of the libhttp-parser can be found upstream with already merged pull-request\footnote{https://github.com/openwrt/packages/pull/5446}.
Unfortunatelly as we will see in subsection \ref{http_parser_problems} Hurdles with http-parser, the successfull build of the updated package may not be enough.
Especially when built package is also a dependency for other packages.



\section{New package José}

After updating of jansson and libhttp-parser we are kind of familiar with the OpenWrt's Makefiles.
Unfortunatelly José package is not packaged for OpenWrt.
Now comes the time to write makefile on our own.

José is a C-language implementation of the Javascript Object Signing and Encryption standards.
Specifically, José aims towards implementing the following standards:
\begin{itemize}
    \item RFC 7520 - Examples of JSON Object Signing and Encryption (JOSE) \cite{RFC7520}
    \item RFC 7515 - JSON Web Signature (JWS)        \cite{RFC7515}
    \item RFC 7516 - JSON Web Encryption (JWE)       \cite{RFC7516}
    \item RFC 7517 - JSON Web Key (JWK)              \cite{RFC7517}
    \item RFC 7518 - JSON Web Algorithms (JWA)       \cite{RFC7518}
    \item RFC 7519 - JSON Web Token (JWT)            \cite{RFC7519}
    \item RFC 7638 - JSON Web Key (JWK) Thumbprint   \cite{RFC7638}
\end{itemize}

JOSE (Javascript Object Signing and Encryption) is a framework intended to provide a method to securely transfer claims (such as authorization information) between parties.
Tang uses JWKs in comunication between client and server.
Both POST request and reply bodies are JWK objects\cite{jose_prog}.



\subsection{Create José}\label{jose}

First, let us create feature branch and directory for new package:
\begin{lstlisting}[columns=fixed,basicstyle=\ttfamily\footnotesize,tabsize=4,backgroundcolor=\color{yellow!10}]
$ git checkout master
$ git checkout -b libhttp-parser-update
$ mkdir -p utils/jose
\end{lstlisting}
At first it does not matter whether new Makefile will be placed whether libs or utils for the build purposes.
We can simply change it as upstream developers would require.

To start with such a work it is good to have some kind of the template.
For the José we used the jansson's Makefile as a template.
Place this "template" Makefile into utils/jose directory and start with editing having the OpenWrt wiki page\footnote{https://wiki.openwrt.org/doc/devel/packages} opened on the side.

Let us go through it from the top to the bottom.
This is first non comment line in the file:
\begin{lstlisting}[columns=fixed,basicstyle=\ttfamily\footnotesize,tabsize=4,backgroundcolor=\color{yellow!10}]
include $(TOPDIR)/rules.mk
\end{lstlisting}
Without this include our Makefile would not work so we will leave it as it is.
The next are the package name, version and release variables.
This have to be the first thing to edit:
\begin{lstlisting}[columns=fixed,basicstyle=\ttfamily\footnotesize,tabsize=4,backgroundcolor=\color{yellow!10}]
PKG_NAME:=jose
PKG_VERSION:=10
PKG_RELEASE:=1
\end{lstlisting}
We will skip the licence variable for José because of the its upstream.

As we defined the version of the package which we desire we should visit the project José pages and browse for the release archive.
José's upstream releases lives on GitHub\footnote{https://github.com/latchset/jose/releases}.
Visit the site and copy link location of the tar.bz2 archive for José release 10.
Now download the archive and as we did when updating packages run sha256sum:
\begin{lstlisting}[columns=fixed,basicstyle=\ttfamily\footnotesize,tabsize=4,backgroundcolor=\color{yellow!10}]
$ wget -P /tmp \
https://github.com/latchset/jose/releases/download/v10/jose-10.tar.bz2
$ sha256sum /tmp/jose-10.tar.bz2 | cut -d " " -f1
5c9cdcfb535c4d9f781393d7530521c72b1dd81caa9934cab6dd752cc7efcd72
\end{lstlisting}
This manual step is reflected in the Makefile as shown:
\begin{lstlisting}[columns=fixed,basicstyle=\ttfamily\footnotesize,tabsize=4,backgroundcolor=\color{yellow!10}]
PKG_SOURCE:=$(PKG_NAME)-$(PKG_VERSION).tar.bz2

PKG_SOURCE_URL:=\
https://github.com/latchset/$(PKG_NAME)/releases/download/v$(PKG_VERSION)/

PKG_HASH:=\
5c9cdcfb535c4d9f781393d7530521c72b1dd81caa9934cab6dd752cc7efcd72
\end{lstlisting}
The {\it PKG\_SOURCE} variable now contain the value of the source archive name.
The {\it PKG\_SOURCE\_URL} provides the wshole path to archive stored on GitHub server and the {\it PKG\_HASH} is used to verify the file integrity.
\begin{lstlisting}[columns=fixed,basicstyle=\ttfamily\footnotesize,tabsize=4,backgroundcolor=\color{yellow!10}]
PKG_INSTALL:=1
PKG_BUILD_PARALLEL:=1

PKG_FIXUP:=autoreconf
include $(INCLUDE_DIR)/package.mk
\end{lstlisting}
Setting {\it PKG\_INSTALL} to "1" will call the package's original "make install" to the {\it PKG\_INSTALL\_DIR} directory.
The {\it PKG\_FIXUP} performs the important {\tt autoreconf -f -i} for project using autotools.
And again without including makefile package.mk the buildroot would not now how to continue build.
Upstream may require to divide it into two packages the library and the tool.
It is a good practice to do with every similar package:
\begin{lstlisting}[columns=fixed,basicstyle=\ttfamily\footnotesize,tabsize=4,backgroundcolor=\color{yellow!10}]
define Package/libjose
  SECTION:=libs
  TITLE:=Provides a full crypto stack...
  DEPENDS:=+zlib +jansson +libopenssl
  URL:=https://github.com/latchset/jose
  MAINTAINER:=Tibor Dudlak <tibor.dudlak@gmail.com>
endef

define Package/$jose
  SECTION:=utils
  TITLE:=Provides a full crypto stack...
  DEPENDS:=+libjose +zlib +jansson +libopenssl
  URL:=https://github.com/latchset/jose
  MAINTAINER:=Tibor Dudlak <tibor.dudlak\@gmail.com>
endef
\end{lstlisting}
To add a nice description for both packages we would add some defines as shown:
\begin{lstlisting}[columns=fixed,basicstyle=\ttfamily\footnotesize,tabsize=4,backgroundcolor=\color{yellow!10}]
define Package/jose/description
	... description text ...
endef

define Package/libjose/description
	... description text ...
endef
\end{lstlisting}
The {\it Build/Configure} section can be skipped if the source doesn't use configure or has a normal config script, otherwise we can put our own commands here or use {\it \$(call Build/Configure/Default,)} to pass in additional arguments after the comma for a standard configure script.
\begin{lstlisting}[columns=fixed,basicstyle=\ttfamily\footnotesize,tabsize=4,backgroundcolor=\color{yellow!10}]
define Build/Configure
	$(call Build/Configure/Default)
endef
\end{lstlisting}
Every library package should have section {\it Build/InstallDev}.
This section is important for linker and buildsystem especially to work correctly when library would be used as dependency (static libs, header files) for other tools or packages.
This section has no use on the target device.
\begin{lstlisting}[columns=fixed,basicstyle=\ttfamily\footnotesize,tabsize=4,backgroundcolor=\color{yellow!10}]
define Build/InstallDev
	$(INSTALL_DIR)	$(1)/usr/lib
	$(INSTALL_DIR)  $(1)/usr/include
	$(INSTALL_DIR)	$(1)/usr/include/$(PKG_NAME)
	$(INSTALL_DIR)	$(1)/usr/lib/pkgconfig
	$(CP)	$(PKG_INSTALL_DIR)/usr/lib/lib$(PKG_NAME).so*	$(1)/usr/lib
	$(CP)	$(PKG_INSTALL_DIR)/usr/include/$(PKG_NAME)/*.h	\
			$(1)/usr/include/$(PKG_NAME)
	$(CP)	$(PKG_BUILD_DIR)/*.pc	$(1)/usr/lib/pkgconfig
endef
\end{lstlisting}
A set of commands to copy files into the ipkg which is represented by the {\it \$(1)} directory.
As source we can use relative paths which will install from the unpacked and compiled source, or {\it \$(PKG\_INSTALL\_DIR)} which is where the files in the Build/Install (not used here) step end up.
\begin{lstlisting}[columns=fixed,basicstyle=\ttfamily\footnotesize,tabsize=4,backgroundcolor=\color{yellow!10}]
define Package/libjose/install
	$(INSTALL_DIR)	$(1)/usr/lib
	$(CP)	$(PKG_INSTALL_DIR)/usr/lib/lib$(PKG_NAME).so*	$(1)/usr/lib/
endef

define Package/jose/install
	$(INSTALL_DIR)	$(1)/usr/bin
	$(INSTALL_BIN)	$(PKG_INSTALL_DIR)/usr/bin/$(PKG_NAME)	$(1)/usr/bin/
endef
\end{lstlisting}
At the bottom of the file is where the real magic happens, {\it BuildPackage} is a macro setup by the earlier include statements.
BuildPackage only takes one argument directly – the name of the package to be built.
All other information is taken from the define blocks.
\begin{lstlisting}[columns=fixed,basicstyle=\ttfamily\footnotesize,tabsize=4,backgroundcolor=\color{yellow!10}]
$(eval $(call BuildPackage,libjose))
$(eval $(call BuildPackage,jose))
\end{lstlisting}
At this point our first Makefile for José is ready.
Let us merge this changes to feeds and try to build our freshly created package.
\begin{lstlisting}[columns=fixed,basicstyle=\ttfamily\footnotesize,tabsize=4,backgroundcolor=\color{yellow!10}]
$ git commit -a
$ git push --set-upstream origin add-jose
$ git checkout new_packages
$ git merge add-jose
\end{lstlisting}
In buildroot run:
\begin{lstlisting}[columns=fixed,basicstyle=\ttfamily\footnotesize,tabsize=4,backgroundcolor=\color{yellow!10}]
$ ./scripts/feeds update packages
$ ./scripts/feeds install jose
$ make package/jose/{clean,compile}
\end{lstlisting}
Note that scritp feeds with an install option will install also missing dependecies of José to be available in buildroot.
Do not worry if the José's build takes time, it has openssl library as dependency and to compile this one it takes some time.
The pull request for adding the Jose package for OpenWrt can be found in its repository\footnote{https://github.com/openwrt/packages/pull/4334}.
