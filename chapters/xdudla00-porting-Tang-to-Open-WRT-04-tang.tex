\documentclass[../xdudla00-porting-Tang-to-Open-WRT.tex]{subfiles}
\begin{document}

\chapter{Tang}\label{tang}
Tang server is an open source project implemented in C \cite{c} programming language, and it binds data to network presence.
What does binding data to network presence really mean?
Essentially, it allows us to make some data to be available only when the system containing the data is on a particular, usually secure, network.

Tang server advertises asymmetric keys\cite{askey} and a client is able to get the list of these signing keys \ref{jose} by HTTP \cite{http} GET request.
The next step is the provisioning step. With the list of these public keys the process of encrypting data may start.
A client chooses one of the asymmetric keys to generate a unique encryption key.
After this, the client encrypts data using the created key. Once the data is encrypted, the key is discarded.
Some small metadata has to be produced as a part of this operation. The client should store this metadata to work with it when decrypting.
Finally, when the client wants to access the encrypted data, it must be able to recover encryption key.
This step starts with loading the stored metadata and ends with simply performing a HTTP\cite{http} POST to Tang server.
Server performs its mathematical operation and sends the result back to the client.
Finally, the client has to calculate the key value, which is better than when server calculates it.
So the Tang server never knew the value of the key and literraly nothing about its clients.

\begin{figure}[h]
    \centering
    %\includegraphics{../figures/placeholder.pdf}
    \caption{Tang model}
    \label{fig:tangmodel}
\end{figure}

On Figure \ref{fig:tangmodel} you can see the Tang model.
It is very similar to Escrow model \ref{fig:escrowmodel} but there are some thing missing.
In fact, there is no longer a need for TLS channel to secure comunication between the client and the server,
 and that is the reason why Tang implements the McCallum-Relyea exchange \ref{fig:mrexchange} as described below.

\section{Binding with Tang}

A client performs an ECDH \cite{ecdh} key exchange in order to generate the binding key.
Then the client discards its own private key so that the Tang server is the only party that can reconstitute the binding key.
To blind the client's public key and the binding key Tang uses a third, ephemeral key \cite{epkey}.
Ephemeral key is generated for each execution of a key establishment process.
Now only the client can unblind his public key and binding key.

\begin{figure}[h]
    \centering
    %\includegraphics[scale=0.7]{../figures/TangModel.pdf}
    \caption{Tang model}
    \label{fig:tangmodel}
\end{figure}

\section{Provisioning}
The client selects one of the Tang server's exchange keys (we will call it sJWK; identified by the use of deriveKey in the sJWK's key\_ops attribute).
The small "s" stands for server's key pair and JWK\cite{JWK} is used format of the message.
The client generates a new (random) JWK (cJWK; c stands for client's key pair).
The client performs its half of a standard ECDH exchange producing dJWK which it uses to encrypt the data.
Afterwards, it discards dJWK and the private key from cJWK.

The client then stores cJWK for later use in the recovery step.
Generally speaking, the client may also store other data, such as the URL \cite{url} of the Tang server or the trusted advertisement signing keys.

Mathematically (capital is private key; g stands for generate) server's operation:
\begin{equation}
    s = g * S
\end{equation}

Mathematically (capital is private key; g stands for generate) client's operation:
\begin{equation}
    c = g * C
\end{equation}

\begin{equation}
    K = s * C
\end{equation}

\section{Recovery}
To recover dJWK after discarding it, the client generates a third ephemeral key (eJWK).
Using eJWK, the client performs elliptic curve group addition of eJWK and cJWK, producing xJWK. The client POSTs xJWK to the server.

The server then performs its half of the ECDH key exchange using xJWK and sJWK, producing yJWK. The server returns yJWK to the client.

The client then performs half of an ECDH key exchange between eJWK and sJWK, producing zJWK. Subtracing zJWK from yJWK produces dJWK again.

Mathematically (capital is private key; g stands for generate) client's operation:

\begin{equation}
    e = g * E
\end{equation}

\begin{equation}
    x = c + e
\end{equation}

Expressed mathematically (capital is private key) server's operation:
\begin{equation}
    y = x * S
\end{equation}

Expressed mathematically (capital is private key) client's operation:
\begin{equation}
    z = s * E
\end{equation}

\begin{equation}
    K = y - z
\end{equation}

\section{Security}

We can now compare Tang and Escrow. In contrast, Tang is stateless and doesn't require TLS \cite{tls} or authentication.
Tang also has limited knowledge. Unlike escrows, where the server has knowledge of every key ever used, Tang never sees a single client key.
Tang never gains any identifying information from the client.

\begin{table}[h]
\centering
\label{compare}
\begin{tabular}{@{}lll@{}}
\toprule
               & Escrow   & Tang                         \\ \midrule
Stateless      & No       & Yes                          \\
SSL/TLS        & Required & Optional                     \\
X.509          & Required & Optional                     \\
Authentication & Required & Optional                     \\
Anonymous      & No       & Yes                          \\ \bottomrule
\end{tabular}
\caption{Comparing Escrow and Tang}
\end{table}

Let's think about the security of Tang system. Is it really secure without an encrypted channel or even without authentication?
So long as the client discards its private key, the client cannot recover dJWK without the Tang server.
This is fundamentally the same assumption used by Diffie-Hellman (and ECDH)\cite{ecdh}.

\subsection{Man-in-the-Middle attack}
In this case \cite{mitm}, the eavesdropper in this case sees the client send xJWK and receive yJWK.
Since, these packets are blinded by eJWK, only the party that can unblind these values is the client itself (since only it has eJWK's private key).
Thus, the MitM attack fails.
\subsection{Compromise the client to gain access to cJWK}
It is of utmost importance that the client protects cJWK from prying eyes.
This may include device permissions, filesystem permissions, security frameworks (such as SELinux \cite{selinux}- Security-Enhanced Linux) or even the use of hardware encryption such as a TPM.
How precisely this is accomplished is an exercise left to the client implementation.
\subsection{Compromise the server to gain access to sJWK's private key}
The Tang server must protect the private key for sJWK.
In this implementation, access is controlled by filesystem permissions and the service's policy.
An alternative implementation might use hardware cryptography (for example, an HSM \cite{hsm}) to protect the private key.
\section{Building Tang}

Tang is originally packaged for Fedora OS\cite{fedora} version 23 and later but we can build it from source of course.
It relies on few other software libraries:

\begin{itemize}
\item http-parser \ref{http-parser}
\item systemd / xinetd \ref{systemd}
\item jose \ref{jose}
    \begin{itemize}
    \item jansson \ref{jansson}
    \item openssl \ref{openssl}
    \item zlib \ref{zlib}
    \end{itemize}
\end{itemize}

To build it from source, download source from poject's GitHub \cite{github} or clone~it.
Make sure you have all needed dependencies installed and then run:

{\tt \$ autoreconf -if}

{\tt \$ ./configure --prefix=/usr}

{\tt \$ make}

{\tt \$ sudo make install}

Optionally to run tests:

{\tt \$ make check}

\subsection{http-parser}\label{http-parser}
Tang uses this parser for both parsing HTTP requests and HTTP responses.
You can find this parser on its own GitHub \cite{http-parser}.

\subsection{systemd / xinetd}\label{systemd}
systemd \cite{systemd} is a suite of basic building blocks for a Linux \cite{linux} system.
It provides a system and service manager that runs as PID \cite{pid} 1 and starts the rest of the system.
systemd provides aggressive parallelization capabilities, uses socket \cite{socket} and D-Bus \cite{Dbus} activation for starting services,
 offers on-demand starting of daemons, keeps track of processes using Linux control groups, maintains mount and automount points,
 and implements an elaborate transactional dependency-based service control logic.

\subsection{José}\label{jose}
José \cite{Jos} is a C-language implementation of the Javascript \cite{javascript} Object Signing and Encryption standards.
Specifically, José aims towards implementing the following standards:
\begin{itemize}
   \item RFC 7515 - JSON Web Signature (JWS)        \cite{JWS}
   \item RFC 7516 - JSON Web Encryption (JWE)       \cite{JWE}
   \item RFC 7517 - JSON Web Key (JWK)              \cite{JWK}
   \item RFC 7518 - JSON Web Algorithms (JWA)       \cite{JWA}
   \item RFC 7519 - JSON Web Token (JWT)            \cite{JWT}
   \item RFC 7520 - Examples of ... JOSE            \cite{exJose}
   \item RFC 7638 - JSON Web Key (JWK) Thumbprint   \cite{JWK}
\end{itemize}

JOSE (Javascript Object Signing and Encryption) is a framework intended to provide a method to securely transfer claims (such as authorization information) between parties.

Tang uses JWKs in comunication between client and server. Both POST request and reply bodies are JWK objects.

\subsection{jansson}\label{jansson}
Jansson \cite{jansson}(licenced under MIT \cite{mit} licence) is a C library for encoding, decoding and manipulating JSON data. It features:
\begin{itemize}

    \item Simple and intuitive API and data model
    \item Comprehensive documentation
    \item No dependencies on other libraries
    \item Full Unicode support (UTF-8)
    \item Extensive test suite
\end{itemize}

\subsection{OpenSSL}\label{openssl}
OpenSSL \cite{openssl} contains an open-source implementation of the Transport Layer Security (TLS) and Secure Sockets Layer (SSL) protocols.
It is used by network applications to secure communication between two parties over network.

\subsection{zlib}\label{zlib}
Library zlib \cite{zlib} is used for data compression.

\section{Server enablement}
Enabling a Tang server is a two-step process.
First, enable and start the service using systemd.

{\tt\begin{verbatim} $ sudo systemctl enable tangd-update.path\end{verbatim}
}

{\tt\begin{verbatim} $ sudo systemctl start tangd-update.path\end{verbatim}
}

{\tt\begin{verbatim} $ sudo systemctl enable tangd.socket\end{verbatim}
}

{\tt\begin{verbatim} $ sudo systemctl start tangd.socket\end{verbatim}
}

Second, generate a signing key and an exchange key.

{\tt\begin{verbatim} $ sudo jose gen -t '{"alg":"ES256"}' -o /var/db/tang/sig.jwk\end{verbatim}
}

{\tt\begin{verbatim} $ sudo jose gen -t '{"kty":"EC","crv":"P-256","key_ops":["deriveKey"]}' \
        -o /var/db/tang/exc.jwk\end{verbatim}
}

Now we are up and running using sig.jwk as \todo{asdf}

\end{document}
